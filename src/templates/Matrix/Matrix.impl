#include "Matrix.h"
#include <algorithm> // swap
#include <iostream>
#include <stdexcept> // domain_error

template<typename T>
Matrix<T>::Matrix(int nrows, int ncols)
    : nrows {nrows}, ncols {ncols}
{
    elements = new T* [nrows];
    elements[0] = new T[nrows * ncols] {};
    for (int i = 1; i < nrows; i++) {
        elements[i] = elements[i - 1] + ncols;
    }
}

template<typename T>
Matrix<T>::Matrix(std::initializer_list<std::initializer_list<T>> list)
    : Matrix(list.size(), (*list.begin()).size())
{
    int i = 0, j = 0;

    for (const auto& row : list) {
        for (const auto& elem : row) {
            elements[i][j++] = elem;
        }
        i++;
        j = 0;
    }
}

template<typename T>
Matrix<T>::Matrix(const Matrix<T>& other)
    : Matrix(other.nrows, other.ncols)
{
    for (int i = 0; i < nrows; i++)
        for (int j = 0; j < ncols; j++)
            elements[i][j] = other.elements[i][j];
}

template<typename T>
Matrix<T>::Matrix(Matrix<T>&& other)
    : nrows {other.nrows}, ncols {other.ncols}, elements {other.elements}
{
    std::cout << "Matrix(Matrix&&)\n";
    other.nrows = other.ncols = 0;
    other.elements = nullptr;
}

template<typename T>
Matrix<T>& Matrix<T>::operator= (Matrix<T> other)
{
    if (this != &other) {
        swap(*this, other);
    }

    return *this;
}

template<typename T>
Matrix<T>& Matrix<T>::operator= (Matrix<T>&& other)
{
    std::cout << "operator= (Matrix&&)\n";
    if (this != &other) {
        nrows = other.nrows;
        ncols = other.ncols;
        elements = other.elements;
        other.nrows = other.ncols = 0;
        other.elements = nullptr;
    }

    return *this;
}

template<typename T>
Matrix<T> operator+ (Matrix<T> lhs, const Matrix<T>& rhs)
{
    if (lhs.rows() != rhs.rows() || lhs.cols() != rhs.cols()) {
        throw std::domain_error("Matrices of different sizes");
    }

    for (int i = 0; i < lhs.rows(); i++)
        for (int j = 0; j < lhs.cols(); j++)
            lhs[i][j] += rhs[i][j];

    return lhs;
}

template<typename T>
Matrix<T> operator- (Matrix<T> lhs, const Matrix<T>& rhs)
{
    if (lhs.rows() != rhs.rows() || lhs.cols() != rhs.cols()) {
        throw std::domain_error("Matrices of different sizes");
    }

    for (int i = 0; i < lhs.rows(); i++)
        for (int j = 0; j < lhs.cols(); j++)
            lhs[i][j] -= rhs[i][j];

    return lhs;
}

template<typename T>
Matrix<T> operator* (const Matrix<T>& lhs, const Matrix<T>& rhs)
{
    if (lhs.cols() != rhs.rows()) {
        throw std::domain_error("Matrices can't be multiplied (A.columns != B.rows)");
    }

    Matrix<T> result(lhs.rows(), rhs.cols());

    for (int i = 0; i < lhs.rows(); i++)
        for (int j = 0; j < rhs.cols(); j++)
            for (int k = 0; k < lhs.cols(); k++)
                result[i][j] += lhs[i][k] * rhs[k][j];

    return result;
}

template<typename T>
std::ostream& operator<< (std::ostream& os, const Matrix<T>& matrix)
{
    for (int i = 0; i < matrix.rows(); i++) {
        for (int j = 0; j < matrix.cols(); j++) {
            os << matrix[i][j] << ' ';
        }
        os << '\n';
    }

    return os;
}

template<typename T>
void swap(Matrix<T>& a, Matrix<T>& b)
{
    std::swap(a.nrows, b.nrows);
    std::swap(a.ncols, b.ncols);
    std::swap(a.elements, b.elements);
}
